<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hi,我是王同学</title>
    <link>https://PolarBear-Wxx.github.io/</link>
    <description>Recent content on Hi,我是王同学</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 May 2020 16:08:20 +0800</lastBuildDate>
    
	<atom:link href="https://PolarBear-Wxx.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>First Acquaintance with Red-Black-Tree</title>
      <link>https://PolarBear-Wxx.github.io/post/first-acquaintance-with-rbtree/</link>
      <pubDate>Mon, 18 May 2020 16:08:20 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/first-acquaintance-with-rbtree/</guid>
      <description>笔记-初识红黑树  了解红黑树之前，先看一下2-3树，他们两者之间是等价的。
2-3树：  满足二分搜索树的基本性质。 节点可以存放一个或者两个元素； 每个元素有两个或者三个孩子。 2-3树是一棵绝对平衡（从根节点到任意一个叶子节点所经过的节点数是相同的）的树。 添加元素时（先按二分搜索树的规则去找往哪加），不会添加到一个空的节点上去，而是和先它最后找到的那个叶子节点做一个融合，2节点到3节点没必要拆，3节点到4节点就可以拆了。 怎么拆才能保持绝对平衡呢？  插入2节点（一个元素），很简单，直接融合，成为3节点 插入3节点（两个元素），融合后形成4节点，然后拆分成3个2节点 插入3节点，（该3节点）父亲节点是2节点，&amp;hellip;&amp;hellip;（拿起笔画一画，哈哈哈） 插入3节点，父亲节点是3节点，&amp;hellip;&amp;hellip;.    红黑树和2-3树的等价性：  实际上我们不希望一个节点既可能是2节点又可能是3节点，我们希望一个节点就是一个可以存放一个元素的节点。 2-3树的3节点对应生成红黑树中的一个红节点。  红黑树   红黑树的节点或者是红色的，或者是黑色的。
  根节点是黑色的。
  任意一个叶子节点（最后的空节点）是黑色的。
  如果一个节点是红色的，那么它的孩子节点都是黑色的。
  从任意一个节点到叶子节点，经过的黑色节点数是一样的。
  绝对“黑”平衡，本质上说，是因为2-3树保持着绝对平衡。
  严格意义上讲，红黑树并不是平衡的，其最大高度可能达到2log(n)，即其所对应的2-3树都是3节点。
    红黑树的所有红色节点都是向左倾斜的（因为我们从一个2-3树向红黑树转变时就是这样干的）。
  虽然红黑树的查找，修改等操作的时间复杂度也是O(log(n))的，但其可能需要2log(n)，也就是说，好像还不如AVL？
 但是，这并不影响红黑树是一个非常重要的数据结构，因为红黑树的优势在添加和删除操作。 如果处理的数据是固定的，即不需要或很少添加或删除元素，而需要大量的查找操作，那就不建议红黑树了。    Java.util中的TreeMap和TreeSet就是用红黑树实现的。
  BST、AVL、RBT性能比较  对于完全随机的数据，普通的二分搜索树很好用！  缺点：极端情况下（完全有序）退化成链表（或者高度不平衡）。   对于查询较多的使用情况，AVL很好用！  红黑树牺牲了平衡性（2log(n)的高度）。   红黑树的统计性能更优，所谓统计性能就是指综合‘’增删改查‘’所有的操作，红黑树优于“增删”，劣于“查”。 当然，他们三者都保持了“有序性”。  一个拓展：Splay Tree （伸展树）  局部性原理：刚被访问的内容下次高概率再次被访问。  </description>
    </item>
    
    <item>
      <title>评论区测试</title>
      <link>https://PolarBear-Wxx.github.io/post/%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 21 Apr 2020 08:07:30 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%B5%8B%E8%AF%95/</guid>
      <description>欢迎大家积极留言   本文主要用于测试刚推出的评论区功能 欢迎大家积极留言，感激不尽 文明用语哦！  &amp;hellip;(偷偷说，这次还被迫换了头像&amp;hellip;哼，自由，不存在的！)
聊个话题吧：你觉得你什么时候能开学？哈哈哈</description>
    </item>
    
    <item>
      <title>My first blog</title>
      <link>https://PolarBear-Wxx.github.io/post/blog/</link>
      <pubDate>Sat, 18 Apr 2020 21:38:32 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/blog/</guid>
      <description>开启我的博客之旅   本文记录了：
  我为什么想拥有自己的博客 我为此做了哪些准备 我经历什么。。。 题外话（一点都不题外哦）    一、我为什么想拥有自己的博客  作为一个刚踏进IT界的渣渣来说，计算机技术带给我的体验不仅仅是让我觉得自己是那么的渺小和卑微，更多是对于这世界的惊叹和向往。小到让我思考了很久，并不断揣摩的快速排序算法，大到诸如git之类的天才般的作品，无论是攻克它们的成就感还是仰视它们的愉悦感，都让我不禁想要做一件事，那就是：记录我和它们的点点滴滴。
 就这样，在2020年的4月18号，我萌生了一个想法：我想拥有自己的博客！
二、我为此做了哪些准备  我很喜欢耐克那句非常经典的广告语：Just Do It（喜欢到我觉得以后我的每一个博客可能都会以它开始）。
 OK，言归正传，在我决定要创建自己的博客之后。在第一时间，我去百度了一下博客的定义：网络日志&amp;hellip;没错，是我想要的东西。(不开玩笑，我真去查了。)然后就是各种搜索怎么创建自己的博客，因为直接在像CSDN这种平台发布博客对我来说是不太能接受的，我总觉得那种博客不是我自己的东西一样。（纯个人问题，不带有任何褒贬！）
 首先，我去了B站，看了几个关于制作博客的视频。大部分视频的标题是“十分钟带你&amp;hellip;”、“八分钟让你创建自己的&amp;hellip;”这种，这些视频教程在现在看来可能不那么完美，但确实能给一个小白带来一场的洗礼。从这些视频中我获取了以下信息：
  当下流行的创建自己的博客的方式有两种：  Hexo + Node.js + Git Hugo + Git   我可以把我的博客托管到GitHub Pages 我只需要简单掌握一下MarkDown就可以写自己的博客了 我甚至可以用别人设计好的主题    原来创建自己的博客那么简单！
 在Hexo和Hugo之间，我选择了Hugo，因为它更轻量，而且足够快捷。
三、我经历了什么。。。  在决定使用Hugo框架之后，我快速地浏览了Hugo官网，Hugo对自己的定义是：&amp;ldquo;Hugo is one of the most popular open-source static site generators.&amp;ldquo;它是一个开源的静态网站生成器，拥有诸多优点，正如它自己介绍的那样，它足够快，足够灵活，足够有趣。然后我很快地完成了Hugo官网上的Quick Start。
 接下来，怀着一颗求知若渴的心，我吭哧瘪肚地看完了Docs里的Getting Started部分和Hugo Modules部分，虽然确实能丰富我的知识，但是似乎对于只想要写个博客的我也没有太大的意义。当然了，对于想要把站点托管在GitHub Pages上的同学来说，Host on GitHub是不容忽略的教程，该教程机智地使用两个远程仓库来分别管理hugo项目和hugo项目生成的public目录，并以“子模块”的方式魔幻般地把作为hugo项目仓库下的一个子文件夹的public目录对接到了GitHub Pages提供的站点仓库，这对于博客的维护和发布来说，简直不要太舒服！这也让我进一步见识到了Git的伟大。此外，该教程提供的使用deploy.</description>
    </item>
    
  </channel>
</rss>