<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hi,我是王同学</title>
    <link>https://PolarBear-Wxx.github.io/post/</link>
    <description>Recent content in Posts on Hi,我是王同学</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 11 Jul 2020 21:50:59 +0800</lastBuildDate>
    
	<atom:link href="https://PolarBear-Wxx.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Shell编程下</title>
      <link>https://PolarBear-Wxx.github.io/post/shell%E7%BC%96%E7%A8%8B%E4%B8%8B/</link>
      <pubDate>Sat, 11 Jul 2020 21:50:59 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/shell%E7%BC%96%E7%A8%8B%E4%B8%8B/</guid>
      <description>小白笔记，大佬绕道，打扰了！   流程控制语句
   条件判断式语句
  按照文件类型进行判断
   测试选项 作用     -b 文件 判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）   -c 文件 判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）   -d 文件 判断该文件是否存在，并且是否为目录文件（是目录文件为真）   -e 文件 判断该文件是否存在（存在为真）   -f 文件 判断该文件是否存在，并且是否为普通文件（是普通文件为真）   -L 文件 判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）   -p 文件 判断该文件是否存在，并且是否为管道文件（是管道文件为真）   -s 文件 判断该文件是否存在，并且是否为非空（非空为真）   -S 文件 判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）    两种判断格式：
  test -e /root/install.</description>
    </item>
    
    <item>
      <title>Shell编程中</title>
      <link>https://PolarBear-Wxx.github.io/post/shell%E7%BC%96%E7%A8%8B%E4%B8%AD/</link>
      <pubDate>Sat, 11 Jul 2020 17:40:39 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/shell%E7%BC%96%E7%A8%8B%E4%B8%AD/</guid>
      <description>小白笔记，大佬绕道，打扰了！   正则表达式
   正则表达式
  正则表达式是用于描述字符排列和匹配模式的一种语法规则，它主要用于字符串的模式分割、匹配、查找及替换操作
  正则表达式与通配符：（绝大多数的语言都支持正则表达式，但是没有通配符的概念）
 正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed等命令可以支持正则表达式 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了    通配符
*：	匹配任意内容
？：	匹配任意一个内容
[]：	匹配中括号中的一个字符
  基础正则表达式（扩展正则表达式就不具体说了，比如 ？、（），不同语言的正则表达式还是有些区别的）
   元字符 作用     * 前一个字符匹配 0 次或任意多次   . 匹配除了换行符外任意一个字符   ^ 匹配行首。例如：^hello会匹配以hello开头的行   $ 匹配行尾。例如：^hello会匹配以hello结尾的行   [] 匹配中括号中指定的任意一个字符。例如：[0-9]、[aoeiu]、[a-z][0-9]   [^] 匹配除中括号的字符外的任意一个字符。例如，[^0-9]匹配任意一个非数字字符；[^a-zA-Z]   \ 转义符。用于取消特殊符号的含义   \{n\} 其前面的字符恰好出现n次（由于正则是包含匹配，可能更多次）。例如：[0-9]\{4\}匹配4位数字，[1][3-8][0-9]\{9\}匹配手机号码   \{n,\} 其前面的字符出现不小于 n 次。例如：[0-9]\{2,\}表示两位及以上的数字   \{n,m\} 其前面的字符至少出现n次，最多出现m次。例如：[a-z]\{6,8\}匹配6到8位的小写字母      “*” 前一个字符匹配0次，或任意多次（和通配符的区别还是挺大的）</description>
    </item>
    
    <item>
      <title>Shell编程上</title>
      <link>https://PolarBear-Wxx.github.io/post/shell%E7%BC%96%E7%A8%8B%E4%B8%8A/</link>
      <pubDate>Fri, 10 Jul 2020 23:44:13 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/shell%E7%BC%96%E7%A8%8B%E4%B8%8A/</guid>
      <description>小白笔记，大佬绕道，打扰了！  Shell和其它语言的对比：
 php和java主要实现功能 Shell简化管理操作   Shell基础
  Bash变量
   什么是变量及变量分类
 变量是计算机内存的单元，其中存放的值可以改变 变量让你能够吧程序中准备使用的每一段数据都赋给一个简短、易于记忆的名字，因此他们十分有用 变量命名规则：  变量名必须以字母或下划线打头，名字中间只能由字母、数字和下划线组成 变量名的长度不得超过255个字符（鸡肋啊这条） 变量名在有效的范围必须是唯一的 在Bash中，变量的默认类型都是字符串型 在任何系统当中，目录名、文件名、变量名都要有含义（别乱起名）   变量按照存储数据分类  字符串型（Shell中默认都是字符串，这点很别扭） 整型 浮点型（就是小数，其他语言可能还分单精度、双精度） 日期型 其他      用户自定义变量：变量是用户自己定义的
  变量名=变量值
 等号两边不能有空格，例如：x=5 如果变量值中有空格要用双引号括起来（单引号也行，区别见Shell基础），例如：x=“bian liang”    变量调用
echo $变量名（方法之一）
  变量叠加
x=123
x=**“$x”**456（这个更好记一些）
x=$(x)789
echo $x
123456789
  变量查看
set
#查询系统下所有已存在的变量
选项：
​	-u：如果设定此选项，调用未声明变量时会报错（默认无任何提示）</description>
    </item>
    
    <item>
      <title>Linux网络管理</title>
      <link>https://PolarBear-Wxx.github.io/post/linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 08 Jul 2020 22:46:50 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</guid>
      <description>小白笔记，大佬绕道，打扰了！   网络基础    ISO/OSI七层模型
 ISO：国际标准化组织（International Organization for Standardization，ISO） OSI：开放系统互联模型（Open System Interconnection Reference Model，缩写为 OSI） IOS：（苹果手机操作系统？）在计算机网络中，IOS是互联网操作系统，是思科公司为其网络设备开发的操作维护系统     层级 主要功能     应用层 用户接口   表示层 数据的表现形式、特定功能的实现如-加密   会话层 对应用会话的管理、同步   传输层 可靠与不可靠的传输、传输前的错误检测、流控   网络层 提供逻辑地址、选路   数据链路层 成帧、用MAC地址访问媒介、错误检测与修正   物理层 设备之间的比特流的传输、物理接口、电气特性      TCP/IP四层模型
 应用层：对应OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS 、SMTP等。 传输层：对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP：可靠的、面向连接的）和用户数据报协议（UDP：不可靠的，面向无连接的）。 网际互联层：对应OSI参考模型的网络层。主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。 网络接口层：与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互联的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。    TCP/IP模型与OSI模型的比较</description>
    </item>
    
    <item>
      <title>Shell基础</title>
      <link>https://PolarBear-Wxx.github.io/post/shell%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 04 Jul 2020 22:49:16 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/shell%E5%9F%BA%E7%A1%80/</guid>
      <description>小白笔记，大佬绕道，打扰了！   Shell概述    Shell是什么？
 Shell是一个命令行解释器，他为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。 Shell还是一个功能强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。    Shell的分类
 Bourne Shell：从1970年起的Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh。（B Shell基本已经淘汰了，比如它不支持上下左右键快速命令） C Shell：主要在BSD版的Unix系统中使用，其语法和C语言类似而得名。 Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括 sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh； Bash 与 sh 兼容，现在使用的linux就是使用Bash作为用户的基本Shell。    Linux支持的Shell
可以去 /etc/shells 里看看
   脚本的执行方式    echo输出命令
echo [选项] [输出内容]
选项：
​	-e：支持反斜线控制的字符转换
​	\a	输出警告音
​	\b	退格键，也就是向左删除键
​	\n	换行符
​	\r	回车键
​	\t	制表符，也就是 Tab 键
​	\v	垂直制表符</description>
    </item>
    
    <item>
      <title>Linux常用命令</title>
      <link>https://PolarBear-Wxx.github.io/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sat, 04 Jul 2020 22:38:30 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>小白笔记，大佬绕道，打扰了！   命令基本格式    命令提示符：例：[root@localhost ~]#
其中：
​	root：当前登录用户
​	localhost ： 主机名
​	~： 当前所在目录（家目录 ~ ：超级用户在 /root ；普通用户在/home/username/）
​	#： 超级用户提示符，普通用户提示符是$
  命令 [选项] [参数]
注意：有时候不需要加选项和参数
​	[]中的内容为可选项
​	个别命令使用不遵循此格式；
​	当有多个选项时，可以写在一起；
​	简化选项与完整选项，例：-a 等于 &amp;ndash;all
  查询目录中的内容： ls
ls [选项] [文件或目录]
选项：
​	-a	显示隐藏文件在内的所有文件（all）
​	-l	显示详细信息（longlist）
​	-d	查看目录属性（directory）
​	-h	人性化显示文件大小（human）
​	-i	显示inode
  文件属性：-rw-r&amp;ndash;r&amp;ndash; （Linux中一切内容皆文件，所有内容以文件形式保存，包括硬件。）
==&amp;gt; -文件类型（- 文件、 d 目录、l 软连接文件、&amp;hellip;&amp;hellip;）</description>
    </item>
    
    <item>
      <title>First Acquaintance with Red-Black-Tree</title>
      <link>https://PolarBear-Wxx.github.io/post/first-acquaintance-with-rbtree/</link>
      <pubDate>Mon, 18 May 2020 16:08:20 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/first-acquaintance-with-rbtree/</guid>
      <description>笔记-初识红黑树  了解红黑树之前，先看一下2-3树，他们两者之间是等价的。
2-3树：  满足二分搜索树的基本性质。 节点可以存放一个或者两个元素； 每个元素有两个或者三个孩子。 2-3树是一棵绝对平衡（从根节点到任意一个叶子节点所经过的节点数是相同的）的树。 添加元素时（先按二分搜索树的规则去找往哪加），不会添加到一个空的节点上去，而是和先它最后找到的那个叶子节点做一个融合，2节点到3节点没必要拆，3节点到4节点就可以拆了。 怎么拆才能保持绝对平衡呢？  插入2节点（一个元素），很简单，直接融合，成为3节点 插入3节点（两个元素），融合后形成4节点，然后拆分成3个2节点 插入3节点，（该3节点）父亲节点是2节点，&amp;hellip;&amp;hellip;（拿起笔画一画，哈哈哈） 插入3节点，父亲节点是3节点，&amp;hellip;&amp;hellip;.    红黑树和2-3树的等价性：  实际上我们不希望一个节点既可能是2节点又可能是3节点，我们希望一个节点就是一个可以存放一个元素的节点。 2-3树的3节点对应生成红黑树中的一个红节点。  红黑树   红黑树的节点或者是红色的，或者是黑色的。
  根节点是黑色的。
  任意一个叶子节点（最后的空节点）是黑色的。
  如果一个节点是红色的，那么它的孩子节点都是黑色的。
  从任意一个节点到叶子节点，经过的黑色节点数是一样的。
  绝对“黑”平衡，本质上说，是因为2-3树保持着绝对平衡。
  严格意义上讲，红黑树并不是平衡的，其最大高度可能达到2log(n)，即其所对应的2-3树都是3节点。
    红黑树的所有红色节点都是向左倾斜的（因为我们从一个2-3树向红黑树转变时就是这样干的）。
  虽然红黑树的查找，修改等操作的时间复杂度也是O(log(n))的，但其可能需要2log(n)，也就是说，好像还不如AVL？
 但是，这并不影响红黑树是一个非常重要的数据结构，因为红黑树的优势在添加和删除操作。 如果处理的数据是固定的，即不需要或很少添加或删除元素，而需要大量的查找操作，那就不建议红黑树了。    Java.util中的TreeMap和TreeSet就是用红黑树实现的。
  BST、AVL、RBT性能比较  对于完全随机的数据，普通的二分搜索树很好用！  缺点：极端情况下（完全有序）退化成链表（或者高度不平衡）。   对于查询较多的使用情况，AVL很好用！  红黑树牺牲了平衡性（2log(n)的高度）。   红黑树的统计性能更优，所谓统计性能就是指综合‘’增删改查‘’所有的操作，红黑树优于“增删”，劣于“查”。 当然，他们三者都保持了“有序性”。  一个拓展：Splay Tree （伸展树）  局部性原理：刚被访问的内容下次高概率再次被访问。  </description>
    </item>
    
    <item>
      <title>评论区测试</title>
      <link>https://PolarBear-Wxx.github.io/post/%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 21 Apr 2020 08:07:30 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%B5%8B%E8%AF%95/</guid>
      <description>欢迎大家积极留言   本文主要用于测试刚推出的评论区功能 欢迎大家积极留言，感激不尽 文明用语哦！  &amp;hellip;(偷偷说，这次还被迫换了头像&amp;hellip;哼，自由，不存在的！)
聊个话题吧：你觉得你什么时候能开学？哈哈哈</description>
    </item>
    
    <item>
      <title>My first blog</title>
      <link>https://PolarBear-Wxx.github.io/post/blog/</link>
      <pubDate>Sat, 18 Apr 2020 21:38:32 +0800</pubDate>
      
      <guid>https://PolarBear-Wxx.github.io/post/blog/</guid>
      <description>开启我的博客之旅   本文记录了：
  我为什么想拥有自己的博客 我为此做了哪些准备 我经历什么。。。 题外话（一点都不题外哦）    一、我为什么想拥有自己的博客  作为一个刚踏进IT界的渣渣来说，计算机技术带给我的体验不仅仅是让我觉得自己是那么的渺小和卑微，更多是对于这世界的惊叹和向往。小到让我思考了很久，并不断揣摩的快速排序算法，大到诸如git之类的天才般的作品，无论是攻克它们的成就感还是仰视它们的愉悦感，都让我不禁想要做一件事，那就是：记录我和它们的点点滴滴。
 就这样，在2020年的4月18号，我萌生了一个想法：我想拥有自己的博客！
二、我为此做了哪些准备  我很喜欢耐克那句非常经典的广告语：Just Do It（喜欢到我觉得以后我的每一个博客可能都会以它开始）。
 OK，言归正传，在我决定要创建自己的博客之后。在第一时间，我去百度了一下博客的定义：网络日志&amp;hellip;没错，是我想要的东西。(不开玩笑，我真去查了。)然后就是各种搜索怎么创建自己的博客，因为直接在像CSDN这种平台发布博客对我来说是不太能接受的，我总觉得那种博客不是我自己的东西一样。（纯个人问题，不带有任何褒贬！）
 首先，我去了B站，看了几个关于制作博客的视频。大部分视频的标题是“十分钟带你&amp;hellip;”、“八分钟让你创建自己的&amp;hellip;”这种，这些视频教程在现在看来可能不那么完美，但确实能给一个小白带来一场的洗礼。从这些视频中我获取了以下信息：
  当下流行的创建自己的博客的方式有两种：  Hexo + Node.js + Git Hugo + Git   我可以把我的博客托管到GitHub Pages 我只需要简单掌握一下MarkDown就可以写自己的博客了 我甚至可以用别人设计好的主题    原来创建自己的博客那么简单！
 在Hexo和Hugo之间，我选择了Hugo，因为它更轻量，而且足够快捷。
三、我经历了什么。。。  在决定使用Hugo框架之后，我快速地浏览了Hugo官网，Hugo对自己的定义是：&amp;ldquo;Hugo is one of the most popular open-source static site generators.&amp;ldquo;它是一个开源的静态网站生成器，拥有诸多优点，正如它自己介绍的那样，它足够快，足够灵活，足够有趣。然后我很快地完成了Hugo官网上的Quick Start。
 接下来，怀着一颗求知若渴的心，我吭哧瘪肚地看完了Docs里的Getting Started部分和Hugo Modules部分，虽然确实能丰富我的知识，但是似乎对于只想要写个博客的我也没有太大的意义。当然了，对于想要把站点托管在GitHub Pages上的同学来说，Host on GitHub是不容忽略的教程，该教程机智地使用两个远程仓库来分别管理hugo项目和hugo项目生成的public目录，并以“子模块”的方式魔幻般地把作为hugo项目仓库下的一个子文件夹的public目录对接到了GitHub Pages提供的站点仓库，这对于博客的维护和发布来说，简直不要太舒服！这也让我进一步见识到了Git的伟大。此外，该教程提供的使用deploy.</description>
    </item>
    
  </channel>
</rss>