<!doctype html>
<html lang="en-us">
  <head>
    <title>First Acquaintance with Red-Black-Tree // Hi,我是王同学</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.69.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Wxx" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://PolarBear-Wxx.github.io/css/main.min.61bb32028587f24ca28522d8d197970c7ef33284e5fffb45a75fcbbb2dbc4dcb.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="First Acquaintance with Red-Black-Tree"/>
<meta name="twitter:description" content="笔记-初识红黑树  了解红黑树之前，先看一下2-3树，他们两者之间是等价的。
2-3树：  满足二分搜索树的基本性质。 节点可以存放一个或者两个元素； 每个元素有两个或者三个孩子。 2-3树是一棵绝对平衡（从根节点到任意一个叶子节点所经过的节点数是相同的）的树。 添加元素时（先按二分搜索树的规则去找往哪加），不会添加到一个空的节点上去，而是和先它最后找到的那个叶子节点做一个融合，2节点到3节点没必要拆，3节点到4节点就可以拆了。 怎么拆才能保持绝对平衡呢？  插入2节点（一个元素），很简单，直接融合，成为3节点 插入3节点（两个元素），融合后形成4节点，然后拆分成3个2节点 插入3节点，（该3节点）父亲节点是2节点，&hellip;&hellip;（拿起笔画一画，哈哈哈） 插入3节点，父亲节点是3节点，&hellip;&hellip;.    红黑树和2-3树的等价性：  实际上我们不希望一个节点既可能是2节点又可能是3节点，我们希望一个节点就是一个可以存放一个元素的节点。 2-3树的3节点对应生成红黑树中的一个红节点。  红黑树   红黑树的节点或者是红色的，或者是黑色的。
  根节点是黑色的。
  任意一个叶子节点（最后的空节点）是黑色的。
  如果一个节点是红色的，那么它的孩子节点都是黑色的。
  从任意一个节点到叶子节点，经过的黑色节点数是一样的。
  绝对“黑”平衡，本质上说，是因为2-3树保持着绝对平衡。
  严格意义上讲，红黑树并不是平衡的，其最大高度可能达到2log(n)，即其所对应的2-3树都是3节点。
    红黑树的所有红色节点都是向左倾斜的（因为我们从一个2-3树向红黑树转变时就是这样干的）。
  虽然红黑树的查找，修改等操作的时间复杂度也是O(log(n))的，但其可能需要2log(n)，也就是说，好像还不如AVL？
 但是，这并不影响红黑树是一个非常重要的数据结构，因为红黑树的优势在添加和删除操作。 如果处理的数据是固定的，即不需要或很少添加或删除元素，而需要大量的查找操作，那就不建议红黑树了。    Java.util中的TreeMap和TreeSet就是用红黑树实现的。
  BST、AVL、RBT性能比较  对于完全随机的数据，普通的二分搜索树很好用！  缺点：极端情况下（完全有序）退化成链表（或者高度不平衡）。   对于查询较多的使用情况，AVL很好用！  红黑树牺牲了平衡性（2log(n)的高度）。   红黑树的统计性能更优，所谓统计性能就是指综合‘’增删改查‘’所有的操作，红黑树优于“增删”，劣于“查”。 当然，他们三者都保持了“有序性”。  一个拓展：Splay Tree （伸展树）  局部性原理：刚被访问的内容下次高概率再次被访问。  "/>

    <meta property="og:title" content="First Acquaintance with Red-Black-Tree" />
<meta property="og:description" content="笔记-初识红黑树  了解红黑树之前，先看一下2-3树，他们两者之间是等价的。
2-3树：  满足二分搜索树的基本性质。 节点可以存放一个或者两个元素； 每个元素有两个或者三个孩子。 2-3树是一棵绝对平衡（从根节点到任意一个叶子节点所经过的节点数是相同的）的树。 添加元素时（先按二分搜索树的规则去找往哪加），不会添加到一个空的节点上去，而是和先它最后找到的那个叶子节点做一个融合，2节点到3节点没必要拆，3节点到4节点就可以拆了。 怎么拆才能保持绝对平衡呢？  插入2节点（一个元素），很简单，直接融合，成为3节点 插入3节点（两个元素），融合后形成4节点，然后拆分成3个2节点 插入3节点，（该3节点）父亲节点是2节点，&hellip;&hellip;（拿起笔画一画，哈哈哈） 插入3节点，父亲节点是3节点，&hellip;&hellip;.    红黑树和2-3树的等价性：  实际上我们不希望一个节点既可能是2节点又可能是3节点，我们希望一个节点就是一个可以存放一个元素的节点。 2-3树的3节点对应生成红黑树中的一个红节点。  红黑树   红黑树的节点或者是红色的，或者是黑色的。
  根节点是黑色的。
  任意一个叶子节点（最后的空节点）是黑色的。
  如果一个节点是红色的，那么它的孩子节点都是黑色的。
  从任意一个节点到叶子节点，经过的黑色节点数是一样的。
  绝对“黑”平衡，本质上说，是因为2-3树保持着绝对平衡。
  严格意义上讲，红黑树并不是平衡的，其最大高度可能达到2log(n)，即其所对应的2-3树都是3节点。
    红黑树的所有红色节点都是向左倾斜的（因为我们从一个2-3树向红黑树转变时就是这样干的）。
  虽然红黑树的查找，修改等操作的时间复杂度也是O(log(n))的，但其可能需要2log(n)，也就是说，好像还不如AVL？
 但是，这并不影响红黑树是一个非常重要的数据结构，因为红黑树的优势在添加和删除操作。 如果处理的数据是固定的，即不需要或很少添加或删除元素，而需要大量的查找操作，那就不建议红黑树了。    Java.util中的TreeMap和TreeSet就是用红黑树实现的。
  BST、AVL、RBT性能比较  对于完全随机的数据，普通的二分搜索树很好用！  缺点：极端情况下（完全有序）退化成链表（或者高度不平衡）。   对于查询较多的使用情况，AVL很好用！  红黑树牺牲了平衡性（2log(n)的高度）。   红黑树的统计性能更优，所谓统计性能就是指综合‘’增删改查‘’所有的操作，红黑树优于“增删”，劣于“查”。 当然，他们三者都保持了“有序性”。  一个拓展：Splay Tree （伸展树）  局部性原理：刚被访问的内容下次高概率再次被访问。  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://PolarBear-Wxx.github.io/post/first-acquaintance-with-rbtree/" />
<meta property="article:published_time" content="2020-05-18T16:08:20+08:00" />
<meta property="article:modified_time" content="2020-05-18T16:08:20+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://PolarBear-Wxx.github.io"><img class="app-header-avatar" src="/image/avatar2.jpg" alt="Wxx" /></a>
      <h1>Hi,我是王同学</h1>
      <p>Welcome to contact me.</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/PolarBear-Wxx" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="mailto:polar_bear_brother@163.com" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">First Acquaintance with Red-Black-Tree</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 18, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <p><img src="./../../image/just-do-it.png" alt="just-do-it"></p>
<h1 id="笔记-初识红黑树">笔记-初识红黑树</h1>
<hr>
<p>了解红黑树之前，先看一下2-3树，他们两者之间是等价的。</p>
<h3 id="2-3树">2-3树：</h3>
<ul>
<li>满足二分搜索树的基本性质。</li>
<li>节点可以存放一个或者两个元素；</li>
<li>每个元素有两个或者三个孩子。</li>
<li>2-3树是一棵绝对平衡（从根节点到任意一个叶子节点所经过的节点数是相同的）的树。</li>
<li>添加元素时（先按二分搜索树的规则去找往哪加），不会添加到一个空的节点上去，而是和先它最后找到的那个叶子节点做一个融合，2节点到3节点没必要拆，3节点到4节点就可以拆了。</li>
<li>怎么拆才能保持绝对平衡呢？
<ul>
<li>插入2节点（一个元素），很简单，直接融合，成为3节点</li>
<li>插入3节点（两个元素），融合后形成4节点，然后拆分成3个2节点</li>
<li>插入3节点，（该3节点）父亲节点是2节点，&hellip;&hellip;（拿起笔画一画，哈哈哈）</li>
<li>插入3节点，父亲节点是3节点，&hellip;&hellip;.</li>
</ul>
</li>
</ul>
<h3 id="红黑树和2-3树的等价性">红黑树和2-3树的等价性：</h3>
<ul>
<li>实际上我们不希望一个节点既可能是2节点又可能是3节点，我们希望一个节点就是一个可以存放一个元素的节点。</li>
<li>2-3树的3节点对应生成红黑树中的一个红节点。</li>
</ul>
<h3 id="红黑树">红黑树</h3>
<ul>
<li>
<p>红黑树的节点或者是红色的，或者是黑色的。</p>
</li>
<li>
<p>根节点是黑色的。</p>
</li>
<li>
<p>任意一个叶子节点（最后的空节点）是黑色的。</p>
</li>
<li>
<p>如果一个节点是红色的，那么它的孩子节点都是黑色的。</p>
</li>
<li>
<p>从任意一个节点到叶子节点，经过的黑色节点数是一样的。</p>
<ul>
<li>
<p>绝对“黑”平衡，本质上说，是因为2-3树保持着绝对平衡。</p>
</li>
<li>
<p>严格意义上讲，红黑树并不是平衡的，其最大高度可能达到2log(n)，即其所对应的2-3树都是3节点。</p>
</li>
</ul>
</li>
<li>
<p>红黑树的所有红色节点都是向左倾斜的（因为我们从一个2-3树向红黑树转变时就是这样干的）。</p>
</li>
<li>
<p>虽然红黑树的查找，修改等操作的时间复杂度也是O(log(n))的，但其可能需要2log(n)，也就是说，好像还不如AVL？</p>
<ul>
<li>但是，这并不影响红黑树是一个非常重要的数据结构，因为红黑树的优势在添加和删除操作。</li>
<li>如果处理的数据是固定的，即不需要或很少添加或删除元素，而需要大量的查找操作，那就不建议红黑树了。</li>
</ul>
</li>
<li>
<p>Java.util中的TreeMap和TreeSet就是用红黑树实现的。</p>
</li>
</ul>
<h3 id="bstavlrbt性能比较">BST、AVL、RBT性能比较</h3>
<ul>
<li>对于完全随机的数据，普通的二分搜索树很好用！
<ul>
<li>缺点：极端情况下（完全有序）退化成链表（或者高度不平衡）。</li>
</ul>
</li>
<li>对于查询较多的使用情况，AVL很好用！
<ul>
<li>红黑树牺牲了平衡性（2log(n)的高度）。</li>
</ul>
</li>
<li>红黑树的统计性能更优，所谓统计性能就是指综合‘’增删改查‘’所有的操作，红黑树优于“增删”，劣于“查”。</li>
<li>当然，他们三者都保持了“有序性”。</li>
</ul>
<h3 id="一个拓展splay-tree-伸展树">一个拓展：Splay Tree （伸展树）</h3>
<ul>
<li>局部性原理：刚被访问的内容下次高概率再次被访问。</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

  <div class="post-comment">
        
              
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'x8KFUcRuWpKAAhVRy2lcobsv-gzGzoHsz',
        appKey: 's9fa71F98KNTND8jYcRfJKEw',
        notify: 'false', 
        verify: 'false', 
        avatar:'mm', 
        placeholder: '欢迎交流讨论...',
        visitor: 'true'
    });
  </script>
  </div>


    </main>
  </body>
</html>
